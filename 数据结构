载入数据集：先输入data() 会显示出很对数据集，之后直接输入想载入的数据集就好了

1.向量
c()
c(1:100) 会输出1-100
seq(from=1,to=100,by=2) 输出1-100间隔为2
rep(2,5)重复5次2
rep(x,each = 5,times = 2)将x向量重复5次，执行两轮
（但是数据必须是同一类型）

2.向量索引
>x[1]
[1] 1
> x[-19]  就不会输出第19个元素

y <- c(1:10)
> y
 [1]  1  2  3  4  5  6  7  8  9 10
这个逻辑判断是循环使用的
> y[c(T,F,F,T)]
[1] 1 4 5 8 9

%in%
#首先复制两个变量a和
>a <- 1:5
>b <- 3:7
>a %in% b    #看a的元素是否包含在b中输出结果如下：
[1] FALSE FALSE  TRUE  TRUE  TRUE

k表示两个向量之间的匹配
k <- z %in% c("one","two")
> z[k]
[1] "one" "two"

v <- 1:3





3.向量运算
%%表示余数
%/%表示除法

> v[c(4,5,6)] <- c(4,5,6)
> v
[1] 1 2 3 4 5 6
> v[20] <- 4
> v
 [1]  1  2  3  4  5  6 NA NA NA NA NA NA NA NA NA NA NA NA NA  4
 
sqrt(25)
[1] 5
> log(16,base = 2) 以2为底16的对数
log(16)就是以e为底
exp(x) 计算x向量每个元素的指数
 [1]    0.1353353    0.3678794    1.0000000    2.7182818    7.3890561   20.0855369
 [7]   54.5981500  148.4131591  403.4287935 1096.6331584
ceiling返回两个整数表示向量的范围
floor表示返回整数
sum表示总和
range 返回最大最小值
mean均值
var方差
median(vec)中位数
[1] 50.5
> quantile(vec)
    0%    25%    50%    75%   100% 
  1.00  25.75  50.50  75.25 100.00 
> quantile(vec,c(0.4,0.5,0.8))
 40%  50%  80% 
40.6 50.5 80.2 
> t <- c(1,4,2,5,7,9,6)
> t
[1] 1 4 2 5 7 9 6
> which.max(t) 返回最大值所在位置
[1] 6
