载入数据集：先输入data() 会显示出很对数据集，之后直接输入想载入的数据集就好了

1.向量
c()
c(1:100) 会输出1-100
seq(from=1,to=100,by=2) 输出1-100间隔为2
rep(2,5)重复5次2
rep(x,each = 5,times = 2)将x向量重复5次，执行两轮
（但是数据必须是同一类型）

2.向量索引
>x[1]
[1] 1
> x[-19]  就不会输出第19个元素

y <- c(1:10)
> y
 [1]  1  2  3  4  5  6  7  8  9 10
这个逻辑判断是循环使用的
> y[c(T,F,F,T)]
[1] 1 4 5 8 9

%in%
#首先复制两个变量a和
>a <- 1:5
>b <- 3:7
>a %in% b    #看a的元素是否包含在b中输出结果如下：
[1] FALSE FALSE  TRUE  TRUE  TRUE

k表示两个向量之间的匹配
k <- z %in% c("one","two")
> z[k]
[1] "one" "two"

v <- 1:3







3.向量运算
%%表示余数
%/%表示除法

> v[c(4,5,6)] <- c(4,5,6)
> v
[1] 1 2 3 4 5 6
> v[20] <- 4
> v
 [1]  1  2  3  4  5  6 NA NA NA NA NA NA NA NA NA NA NA NA NA  4
 
sqrt(25)
[1] 5
> log(16,base = 2) 以2为底16的对数
log(16)就是以e为底
exp(x) 计算x向量每个元素的指数
 [1]    0.1353353    0.3678794    1.0000000    2.7182818    7.3890561   20.0855369
 [7]   54.5981500  148.4131591  403.4287935 1096.6331584
ceiling返回两个整数表示向量的范围
floor表示返回整数
sum表示总和
range 返回最大最小值
mean均值
var方差
median(vec)中位数
[1] 50.5
> quantile(vec)
    0%    25%    50%    75%   100% 
  1.00  25.75  50.50  75.25 100.00 
> quantile(vec,c(0.4,0.5,0.8))
 40%  50%  80% 
40.6 50.5 80.2 
> t <- c(1,4,2,5,7,9,6)
> t
[1] 1 4 2 5 7 9 6
> which.max(t) 返回最大值所在位置
[1] 6

4.矩阵和数组
heatmap(state.x77)
> x <- 1:20
> x
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
> m <- matrix(x,nrow = 4,ncol = 5)
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20
> 
> m <- matrix(1:20,nrow = 4,ncol = 5)
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20
> matrix(1:20,4)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20
> m <- matrix(1:20,4,byrow = T) T表示按行排序
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    6    7    8    9   10
[3,]   11   12   13   14   15
[4,]   16   17   18   19   20
> m <- matrix(1:20,4,byrow = F) F 表示按纵向排序
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20

rnames <- c("R1","R2","R3","R4")
> rnames
[1] "R1" "R2" "R3" "R4"
> cnames <- c("C1","C2","C3","C4","C5")
> cnames
[1] "C1" "C2" "C3" "C4" "C5"
> dimnames(m) <- list(rnames,cnames)
> m
   C1 C2 C3 C4 C5
R1  1  5  9 13 17
R2  2  6 10 14 18
R3  3  7 11 15 19
R4  4  8 12 16 20

 dim(x) <- c(2,2,5) 生成5个2*2的矩阵
> x
, , 1

     [,1] [,2]
[1,]    1    3
[2,]    2    4

, , 2

     [,1] [,2]
[1,]    5    7
[2,]    6    8

, , 3

     [,1] [,2]
[1,]    9   11
[2,]   10   12

, , 4

     [,1] [,2]
[1,]   13   15
[2,]   14   16

, , 5

     [,1] [,2]
[1,]   17   19
[2,]   18   20


建立数组
d1 <- c("A1","A2")
> d2 <- c("B1","B2","B3")
> d3 <- c("C1","C2","C3","C4")
> z <- array(1:24,c(2,3,4),dimnames = list(d1,d2,d3)) 4个2*3矩阵，矩阵标题都是 d1 d2 d3
> z
, , C1

   B1 B2 B3
A1  1  3  5
A2  2  4  6

, , C2

   B1 B2 B3
A1  7  9 11
A2  8 10 12

, , C3

   B1 B2 B3
A1 13 15 17
A2 14 16 18

, , C4

   B1 B2 B3
A1 19 21 23
A2 20 22 24


m <- matrix(1:20,4,5,byrow = T)
> m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    6    7    8    9   10
[3,]   11   12   13   14   15
[4,]   16   17   18   19   20
> m(1,2)
Error in m(1, 2) : 没有"m"这个函数
> m[1,2]
[1] 2
> m[1,c(2,3,4)]
[1] 2 3 4
> m[2,]
[1]  6  7  8  9 10
> m[,2]
[1]  2  7 12 17
> m[-1,2] 输出第二列但是不输出[2,1]位置的元素
[1]  7 12 17

5.列表（最复杂的数据结构）
可以存向量 矩阵 数据框
